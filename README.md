## 关于项目中Sass扩展语言的使用

如果项目使用`.scss`的样式文件后，样式没有生效，或者项目中的功能卡着无法点击和运行，要检查设置文件`project.config.json`

```xml
{
  ...
  "setting": {
    "useCompilerPlugins": [
      "sass"
    ]
  ...
}
```

确保setting字段中设置了`"useCompilerPlugins": ["sass"]`

## 关于小程序表单提交的数据格式

微信小程序表单的数据默认并不是JSON格式。微信小程序中的表单数据，在用户提交时，是以键值对（name:value）的形式进行组织的，这些数据通常被编码为URL查询字符串或通过POST请求的body发送。

具体来说，当表单提交时，微信小程序会将表单内各个组件（如input、checkbox、radio等）的值收集起来，然后根据这些组件的name属性作为键，对应的值作为值，形成一系列的键值对。这些键值对随后被编码并发送到服务器。

如果开发者希望以JSON格式发送数据，他们需要在小程序端对数据进行序列化处理，即将数据转换为JSON字符串，然后在发送请求时设置正确的Content-Type头部（通常为'application/json'），以便服务器能够正确解析接收到的数据。

因此，微信小程序表单的数据格式取决于开发者如何处理这些数据以及他们如何配置请求。默认情况下，这些数据并不是JSON格式的，而是键值对形式的。开发者需要根据自己的需求来选择合适的数据格式和发送方式。

## 微信小程序的网络请求中，Referer header具有特定的格式和作用，以下是对其的详细解释：

1. 格式

微信小程序网络请求的Referer header的格式固定为：https://servicewechat.com/{appid}/{version}/page-frame.html。其中，{appid}代表小程序的唯一标识，{version}代表小程序的版本号。版本号的值具有特定的含义：

0：表示开发版、体验版以及审核版本。
devtools：表示开发者工具。
其他数值：表示正式版本，通常为一个自增的正整数。

2. 作用

由于Referer header的格式是固定的，并且包含了小程序的appid和版本号信息，因此服务器可以通过解析Referer header来识别请求的来源，进而实现一些特定的功能，如：

- 区分请求来源：通过appid可以区分不同小程序的请求。
- 版本控制：通过版本号可以判断小程序当前所处的版本阶段（开发版、体验版、正式版等），进而进行版本更新或兼容性处理。

3. 注意事项

不可自定义：与普通的Web开发不同，微信小程序的Referer header是不可自定义的。开发者无需在请求头中设置Referer，微信客户端会自动添加。
并发限制：微信小程序对于网络请求的并发数有一定的限制。例如，wx.request、wx.uploadFile、wx.downloadFile的最大并发限制是10个。
后台运行限制：当小程序进入后台运行后，如果5秒内网络请求没有结束，会回调错误信息fail interrupted。在回到前台之前，网络请求接口调用都会无法调用。
综上所述，微信小程序的Referer header是一个包含小程序appid和版本号的固定格式的请求头，用于服务器识别请求来源和进行版本控制。开发者无需手动设置，也无需担心其自定义问题。


## var、let、const三者的区别

- var 声明是全局作用域或函数作用域，而 let 和 const 是块作用域。
- var 变量可以在其作用域内更新和重新声明；let 变量可以更新但不能重新声明；const 变量既不能更新也不能重新声明。
- 它们都被提升到了作用域的顶部。但是，var 变量是用 undefined 初始化的，而 let 和 const 变量不会被初始化。
- var 和 let 可以在不初始化的情况下声明，而 const 必须在声明时初始化。

## 微信小程序中事件绑定的两种方法bindtap与catchtap，它们的区别是什么：

联系的是它们两个都是UI控件事件绑定方法，都可以实现视图层与逻辑层之间的用户动作事件交互，不同的是前者bindtap会把事件回调响应往上传递，俗称冒泡，而后者catchtap不会事件回调响应往上传递，仅在当前UI控件处理后即结束，不会向它的父级控件元素传递。

显而易见，这两种方法对应的场景不同。如果在page页面中某控件元素绑定事件后，但其父级控件元素没有绑定事件，此时用bindtap即可；但其父级控件元素有绑定事件的话，仍旧用bindtap，那么此时点击该控件元素时候，本身的事件响应函数与其父级控件元素的事件响应函数都会被调用执行，这是我们不希望看到的现象，此现象称为“事件穿透”。

## 数据缓存

### 同步缓存API

同步缓存API以“Sync”结尾，例如wx.setStorageSync和wx.getStorageSync。这些API在执行时会阻塞当前线程，直到操作完成。这意味着在调用同步API时，小程序会等待操作完成后再继续执行后续代码。同步缓存的优点是使用简单，不需要处理回调函数，但缺点是可能会导致页面卡顿，影响用户体验‌12。

### 异步缓存API

异步缓存API没有“Sync”后缀，例如wx.setStorage和wx.getStorage。这些API不会阻塞当前线程，可以在后台进行操作，不会影响用户的交互体验。异步缓存的优点是不会导致页面卡顿，提升用户体验，但缺点是需要处理回调函数，代码相对复杂一些‌12。

### 使用场景和性能差异

‌同步缓存‌适用于对响应时间要求不高、不需要频繁读写操作的场景，或者在小程序启动时进行数据初始化。由于同步操作会阻塞线程，可能会导致页面卡顿，因此不建议在用户交互频繁的场景中使用。
‌
异步缓存‌适用于需要频繁读写操作、对用户体验要求较高的场景。异步操作不会阻塞线程，可以提升用户体验，但需要处理回调函数，增加了代码的复杂性。
缓存大小限制

微信小程序的本地缓存大小有限制，单个key的最大存储量为1MB，所有数据的存储上限为10MB‌24。

综上所述，选择同步还是异步缓存API取决于具体的使用场景和对用户体验的要求。在需要快速完成数据读写操作且不关心页面响应的情况下，可以选择同步缓存；而在需要频繁读写且对用户体验有较高要求的情况下，建议使用异步缓存。

## `onReady: function (e) {this.mapCtx = wx.createMapContext('myMap')}` 中，this关键字的作用

```js
onReady: function (e) {
  // 使用 wx.createMapContext 获取 map 上下文
  this.mapCtx = wx.createMapContext('myMap')
}
```


在JavaScript（包括在微信小程序的开发中）中，this关键字是一个非常重要的概念，它指向当前执行上下文中的对象。在你提供的代码片段中，this的作用主要体现在以下几个方面：

- 指向当前组件实例：在微信小程序中，当你定义组件的方法时，如onReady，this默认指向当前组件的实例。这意味着你可以通过this访问组件的数据（data）、属性（properties）、方法（methods）以及其他定义在组件内的成员。

- 存储map上下文：在你的代码中，this.mapCtx = wx.createMapContext('myMap')这行代码的作用是将通过wx.createMapContext获取的地图上下文对象存储到当前组件实例的mapCtx属性中。这样做的目的是为了在组件的其他方法或生命周期函数中能够方便地访问和操作地图上下文。

- 确保数据和方法的一致性和可访问性：通过使用this，你可以确保组件内部的数据和方法在整个组件的生命周期内都是一致和可访问的。这对于维护组件的状态和逻辑非常重要。

- 避免全局变量污染：如果不使用this来存储数据或方法，你可能会倾向于使用全局变量。这会导致代码难以维护，因为全局变量很容易被意外修改，而且它们会在整个应用程序的生命周期内保持存在，这可能导致内存泄漏或意外的行为。

在代码片段中，this关键字用于确保mapCtx能够作为当前组件实例的一个属性被安全地存储和访问，这是组件化编程中常见和推荐的做法。


## 在微信小程序自定义组件中，如果properties和data定义了相同名称的参数，会出现的情况

‌

- 属性冲突‌：在组件的WXML模板中，如果同时使用了properties和data中定义的相同名称的参数，WXML会优先使用properties中定义的参数值。这是因为properties中的属性是开放的，外部页面可以访问，而data中的数据是私有的，外部不能访问‌。

- 数据绑定‌：在组件的JavaScript代码中，可以通过setData方法修改properties的值。但是，需要注意的是，直接修改properties的值并不会触发observers监听器，只有通过setData方法修改才会触发监听器‌。
- 数据访问‌：在组件内部，this.data和this.properties指向的是同一个地址。这意味着在组件内部，可以通过this.data访问到properties的值，反之亦然。但是，需要注意的是，直接修改properties的值并不会影响外部传递进来的值，因为properties的值是只读的，外部页面无法直接修改‌3。

**实际应用场景**

在实际开发中，通常会将需要在组件间传递的数据定义在properties中，而将组件内部的私有数据定义在data中。这样可以更好地管理数据的访问和修改，避免数据冲突和不可预测的行为。例如：

- properties‌：用于接收外部页面传递的数据。

- data‌：用于存储组件内部的私有数据和状态。