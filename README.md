## 关于项目中Sass扩展语言的使用

如果项目使用`.scss`的样式文件后，样式没有生效，或者项目中的功能卡着无法点击和运行，要检查设置文件`project.config.json`

```xml
{
  ...
  "setting": {
    "useCompilerPlugins": [
      "sass"
    ]
  ...
}
```

确保setting字段中设置了`"useCompilerPlugins": ["sass"]`

## 关于小程序表单提交的数据格式

微信小程序表单的数据默认并不是JSON格式。微信小程序中的表单数据，在用户提交时，是以键值对（name:value）的形式进行组织的，这些数据通常被编码为URL查询字符串或通过POST请求的body发送。

具体来说，当表单提交时，微信小程序会将表单内各个组件（如input、checkbox、radio等）的值收集起来，然后根据这些组件的name属性作为键，对应的值作为值，形成一系列的键值对。这些键值对随后被编码并发送到服务器。

如果开发者希望以JSON格式发送数据，他们需要在小程序端对数据进行序列化处理，即将数据转换为JSON字符串，然后在发送请求时设置正确的Content-Type头部（通常为'application/json'），以便服务器能够正确解析接收到的数据。

因此，微信小程序表单的数据格式取决于开发者如何处理这些数据以及他们如何配置请求。默认情况下，这些数据并不是JSON格式的，而是键值对形式的。开发者需要根据自己的需求来选择合适的数据格式和发送方式。

## 微信小程序的网络请求中，Referer header具有特定的格式和作用，以下是对其的详细解释：

1. 格式

微信小程序网络请求的Referer header的格式固定为：https://servicewechat.com/{appid}/{version}/page-frame.html。其中，{appid}代表小程序的唯一标识，{version}代表小程序的版本号。版本号的值具有特定的含义：

0：表示开发版、体验版以及审核版本。
devtools：表示开发者工具。
其他数值：表示正式版本，通常为一个自增的正整数。

2. 作用

由于Referer header的格式是固定的，并且包含了小程序的appid和版本号信息，因此服务器可以通过解析Referer header来识别请求的来源，进而实现一些特定的功能，如：

- 区分请求来源：通过appid可以区分不同小程序的请求。
- 版本控制：通过版本号可以判断小程序当前所处的版本阶段（开发版、体验版、正式版等），进而进行版本更新或兼容性处理。

3. 注意事项

不可自定义：与普通的Web开发不同，微信小程序的Referer header是不可自定义的。开发者无需在请求头中设置Referer，微信客户端会自动添加。
并发限制：微信小程序对于网络请求的并发数有一定的限制。例如，wx.request、wx.uploadFile、wx.downloadFile的最大并发限制是10个。
后台运行限制：当小程序进入后台运行后，如果5秒内网络请求没有结束，会回调错误信息fail interrupted。在回到前台之前，网络请求接口调用都会无法调用。
综上所述，微信小程序的Referer header是一个包含小程序appid和版本号的固定格式的请求头，用于服务器识别请求来源和进行版本控制。开发者无需手动设置，也无需担心其自定义问题。


## var、let、const三者的区别

- var 声明是全局作用域或函数作用域，而 let 和 const 是块作用域。
- var 变量可以在其作用域内更新和重新声明；let 变量可以更新但不能重新声明；const 变量既不能更新也不能重新声明。
- 它们都被提升到了作用域的顶部。但是，var 变量是用 undefined 初始化的，而 let 和 const 变量不会被初始化。
- var 和 let 可以在不初始化的情况下声明，而 const 必须在声明时初始化。

## 微信小程序中事件绑定的两种方法bindtap与catchtap，它们的区别是什么：

联系的是它们两个都是UI控件事件绑定方法，都可以实现视图层与逻辑层之间的用户动作事件交互，不同的是前者bindtap会把事件回调响应往上传递，俗称冒泡，而后者catchtap不会事件回调响应往上传递，仅在当前UI控件处理后即结束，不会向它的父级控件元素传递。

显而易见，这两种方法对应的场景不同。如果在page页面中某控件元素绑定事件后，但其父级控件元素没有绑定事件，此时用bindtap即可；但其父级控件元素有绑定事件的话，仍旧用bindtap，那么此时点击该控件元素时候，本身的事件响应函数与其父级控件元素的事件响应函数都会被调用执行，这是我们不希望看到的现象，此现象称为“事件穿透”。